# О стандартных виджетах

## Создание виджета

У каждого виджета должен быть родитель во время создания, иначе виджет будет невидимым и не получит никаких сообщений. Родительская и минимальная ширина виджета -- единственные общие аргументы всех функций, создающих новый виджет. Другие аргументы могут отличаться, но есть ряд общих свойств. Общая функция создания может выглядеть так (за исключением `Frame`, у которого есть собственный аргумент `frameWidth`: `BorderThick` или `BorderThin`) - обратите внимание, что это не настоящая функция:

```go
CreateWidget(parent, minimalWidth, minimalHeight, title, scale)
```

- `parent` - контейнер, которому принадлежит созданный виджет;
- `minimalWidth` и `minimalHeight` - это ограничения на размеры виджета при изменении размера его родителя. Некоторые виджеты не используют минимальную высоту, потому что они не могут быть выше `1` символа - это виджеты `Radio`, `CheckBox` и `EditField`. Если виджет не должен иметь определенного минимального размера, вы можете установить его на `AutoSize`. В этом случае минимальный размер будет либо вычисляться на лету (например, минимальная ширина метки - это длина его заголовка), либо используются значения по умолчанию (ширина фрейма равна `5`, а высота равна `3`, если они не предоставлены вызывающим кодом). Минимальные размеры можно изменить позже, вызвав функцию виджета `widget.SetConstraints (newMinimalWidth, newMinimalHeight)`. Обратите внимание, что если вы хотите изменить только одно значение, вы можете установить для другого константу `KeepValue`, например `widget.SetConstraints (KeepValue, 10)` изменяет только `MinimHeight` на `10` и сохраняет старое значение `MinimWidth`;
- `title` - текст, отображаемый на виджете. У половины виджетов его нет. Заголовки могут включать специальные теги, которые будут отображаться разными цветами. Подробнее об этом чуть позже;
- `scale` - определяет, во сколько раз быстрее виджет изменяет свой размер при изменении размера его родителя (например, если в контейнере есть два виджета, и первый имеет масштаб `1`, а второй - масштаб `2`, тогда последний виджет растет в два раза быстрее, когда увеличиваются размеры контейнера). Установка для масштаба специальной константы `Fixed` запрещает изменение размера элемента управления, поэтому он всегда имеет постоянный размер.

### Основные методы виджета

Все методы следуют одному правилу: для каждого свойства существует метод **Set[Property]** для его изменения и метод **[Property]** для его чтения. Ниже указаны только сеттеры:

1. Размер и положение: `SetSize(ширина, высота)`, `SetPos(x, y)`
2. Минимальный размер: `SetConstraints(minWidth, minHeight)`
3. Заголовок/текст/подпись: `SetTitle(string)`
4. Отключить или включить виджет - `SetEnable(bool)`. Отключенные элементы управления обычно имеют собственный вид и не реагируют на события мыши и клавиатуры.
5. Активировать элемент управления - `SetActive(bool)`. Окно может иметь только один активный виджет одновременно, поэтому `SetActive` деактивирует ранее активированный элемент управления перед активацией нового.
6. Вкладка управления: `SetTabStop(bool)`. Устанавливает, можно ли выбрать элемент управления, нажав клавишу `TAB`, или элемент управления пропускается при перемещении по виджетам с помощью клавиатуры. В любом случае виджет можно выбрать мышью.
7. Тип раскладки: `SetPack(PackType)`. Устанавливает направление упаковки дочерних виджетов - горизонтальное или вертикальное
8. Пробел между первым (или последним) дочерним элементом и краем виджета: `SetPaddings(identifyX, identifyY)`
9. Пробел между дочерними элементами: `SetGaps(gapX, gapY)`
10. Установить режим масштабирования: `SetScale(scale)`. Функция определяет поведение виджета при изменении размера его родительского элемента. Вы можете запретить изменение размера виджета, установив масштаб на `Fixed`, или вы можете установить коэффициент масштабирования. Подробнее о масштабировании читайте в следующем разделе.
11. Выравнивание текста: `SetAlign(вырывнивание)`. Устанавливает выравнивание заголовка виджета. Свойство применяется к виджетам, которые не позволяют редактировать его содержимое: текст `Label`, заголовок `Frame` и т. д. Многострочные и редактируемые виджеты (`EditField`, `TextView` и т. д.) не используют это свойство. Что касается `TableView` - каждый столбец имеет свое выравнивание.
12. Основные цвета виджета: `SetTextColor(Color)` и `SetBackColor(Color)`. Это цвета по умолчанию для отображения содержимого виджета (подробнее об использовании цвета по умолчанию см. Ниже в разделе «Цветовые теги заголовка»). Существует специальный цвет `Default`, который устанавливается по умолчанию для каждого виджета: если вы установите цвет виджета на `Default`, виджет будет использовать цвета из текущей темы (это работает только для стандартного виджета, включенного в библиотеку). Итак, для простого приложения вам не нужно устанавливать цвета - библиотека сделает это за вас.

## Методы, которые не следуют правилу именования методов (так как они не часто используются)

Цвета активного виджета. Устанавливать их следует с помощью `SetActiveTextColor(Color)` и `SetActiveBackColor(Color)`, но читать следует с помощью `ActiveColors() -> (textColor, backColor)`. Есть несколько виджетов, с которыми пользователь может взаимодействовать, пока эти виджеты активны. Например, только активный `EditField` может быть изменен, только активный `Button` может быть нажат с помощью клавиши `Space`. Установка собственного активного цвета для виджета может помочь легче идентифицировать активный виджет. И, как и в случае с базовым цветом, вы можете использовать цвет по умолчанию, если вас устраивают цвета, предоставляемые текущей темой - тема по умолчанию имеет активные цвета, отличные от основных.

### Как работает масштабирование

Каждый контейнер имеет начальный размер, который рассчитывается как максимум из двух значений: минимальный размер и сумма минимальных размеров его дочерних элементов. Когда контейнер изменяет свой размер, менеджер компоновки изменяет размер дочерних элементов:

1. Рассчитывается разница между новым размером и начальным размером («Дельта»).
2. Контейнер вычисляет общий размер шкалы всех дочерних элементов (`TotalScaleSize`). «Фиксированные» дети имеют масштабный коэффициент, равный 0
3. Каждый дочерний элемент, имеющий масштаб больше `0` (кроме последнего), увеличивается на значение: `child.Scale * Delta / TotalScaleSize`. Число округляется в меньшую сторону. «Дельта» уменьшается на величину. Последний дочерний элемент увеличивается на значение, оставшееся в `Delta`. Итак, в реальной жизни один виджет может расти больше, чем другой, даже если их масштабы равны (пример: у двух дочерних элементов масштаб `1`, размер родительского элемента увеличен на `3`, затем первый увеличивается на `floor(1 * (3 / (1 + 1))) = 1`, а последний увеличивается на `(3 - 1) = 2`

## Цветовые теги заголовка

Каждый виджет может отображать цветной текст: метки, рамки и даже элементы `ListBox` могут быть раскрашены. Способ использования цветов в выходных строках аналогичен способу использования **HTML**. Каждый тег цвета должен начинаться с `<Letter: ColorValue>`. `Letter` должна быть одной из `c`, `t`, `f` или `b` (если `Letter` не входит в список или двоеточие не следует за `Letter`, то текст отображается как есть. Таким образом, вам не нужно избегать угловых скобок, чтобы отображать их в тексте. Используйте тег `b`, чтобы изменить цвет **b**oreground, и `c`, `t` или `f`, чтобы изменить цвет **t**ext или **f**oreground (`c` означает **c**olor). `ColorValue` - это одноцветное значение или список цветов и его модификатор, разделенные пробелом, `+` или `|`. Поддерживаемые цвета: черный, белый, зеленый, желтый, синий, пурпурный, голубой, красный и «default». Последнее значение «default» означает, что должен использоваться соответствующий цвет виджета - фон для `b: default` и для переднего плана -- `f: default`. Поддерживаемые модификаторы: `bold` (или яркость вместо него), `underline` (также поддерживается написание подчеркнутого) и `reverse`. Примеры правильных тегов: `<t: red bold>`, `<t: uderline+blue>`.

Все теги внутри строки работают как триггеры: когда функции рисования передаётся тег, она меняет текущий цвет на цвет тега до тех пор, пока не будет достигнут конец строки другого тега. После печати всей строки цвета возвращаются к значениям по умолчанию. Другими словами, цвета внутри строки являются временными, и вам не нужно сбрасывать цвета на нормальные в конце.

Иногда вам нужно просто выделить только часть другого цвета, а для всех остальных оставить цвета по умолчанию. Просто заключите часть текста между `<c: Color>` и `<c: default>`. Для случая по умолчанию есть ярлык - пустой тег `<b:>` или `<c:>`. Пример: `Label` имеет текст `<c: green> green <c:> text` отображает «green» с зеленым цветом текста, в то время как остальная часть строки отображается с цветом текста `Label`, который также может быть зеленым.

В библиотеке есть набор общедоступных функций для использования в пользовательских виджетах:

- `UnColorizeText` - возвращает текст с удаленными всеми цветовыми тегами
- `AlignColorizedText` - выровнять текст с помощью тегов внутри области определенной ширины
- `SliceColorized` - умная нарезка текста, которая сохраняет тег с самого начала, если тег не входит в диапазон фрагментов. Пример:

`SliceColorized("abc<c: green> def <c: red> hg ", 4, -1)=="<c: green>f<c: red>hg"`

`StringToColor` - получает строку в формате тега и возвращает значение цвета, которое можно использовать в функциях типа `SetTextColor`. Может быть полезно читать цвета из файла конфигурации. `ColorToString` - наоборот, возвращает описание цвета, которое можно использовать в тегах.
